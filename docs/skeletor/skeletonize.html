<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 6.4.2" />
    <title>skeletor.skeletonize API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style type="text/css">/*! * Bootstrap Reboot v5.0.0-beta1 (https://getbootstrap.com/) * Copyright 2011-2020 The Bootstrap Authors * Copyright 2011-2020 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus{outline:dotted 1px;outline:-webkit-focus-ring-color auto 5px}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style type="text/css">/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style type="text/css">/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main{padding:2rem 3vw;}.git-button{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3, .pdoc h4{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../skeletor.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;skeletor</a>


                    <h2>Contents</h2>
                    <ul>
  <li><a href="#references">References</a></li>
</ul>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="function" href="#by_teasar">by_teasar</a>
            </li>
            <li>
                    <a class="function" href="#by_wavefront">by_wavefront</a>
            </li>
            <li>
                    <a class="function" href="#by_vertex_clusters">by_vertex_clusters</a>
            </li>
            <li>
                    <a class="function" href="#by_edge_collapse">by_edge_collapse</a>
            </li>
            <li>
                    <a class="function" href="#by_tangent_ball">by_tangent_ball</a>
            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../skeletor.html">skeletor</a>.skeletonize    </h1>

                        <div class="docstring"><p>The <code><a href="">skeletor.skeletonize</a></code> module contains functions to for skeletonization
of meshes.</p>

<p>There are several approaches to skeletonizing a mesh. Which one to pick depends
(among other things) on the shape of your mesh and the skeleton quality you want
to get out of it. In general, unless you mesh already looks like a tube I
recommend looking into mesh contraction <sup class="footnote-ref" id="fnref-1"><a href="#fn-1">4</a></sup>.</p>

<p>Please see the documentation of the individual functions for details but here
is a quick summary:</p>

<table>
<thead>
<tr>
  <th>function</th>
  <th style="text-align:center;">speed</th>
  <th style="text-align:center;">robust</th>
  <th style="text-align:center;">radii <sup class="footnote-ref" id="fnref-2"><a href="#fn-2">1</a></sup></th>
  <th style="text-align:center;">mesh map <sup class="footnote-ref" id="fnref-3"><a href="#fn-3">2</a></sup></th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code><a href="#by_wavefront">skeletor.skeletonize.by_wavefront()</a></code></td>
  <td style="text-align:center;">+++</td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">yes</td>
  <td style="text-align:center;">yes</td>
  <td>works well for tubular meshes</td>
</tr>
<tr>
  <td><code><a href="#by_vertex_clusters">skeletor.skeletonize.by_vertex_clusters()</a></code></td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">+</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">yes</td>
  <td>best with contracted meshes <sup class="footnote-ref" id="fnref-1"><a href="#fn-1">3</a></sup></td>
</tr>
<tr>
  <td><code><a href="#by_teasar">skeletor.skeletonize.by_teasar()</a></code></td>
  <td style="text-align:center;">+</td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">yes</td>
  <td>works on mesh surface</td>
</tr>
<tr>
  <td><code><a href="#by_tangent_ball">skeletor.skeletonize.by_tangent_ball()</a></code></td>
  <td style="text-align:center;">++</td>
  <td style="text-align:center;">0</td>
  <td style="text-align:center;">yes</td>
  <td style="text-align:center;">yes</td>
  <td>works with mesh normals</td>
</tr>
<tr>
  <td><code><a href="#by_edge_collapse">skeletor.skeletonize.by_edge_collapse()</a></code></td>
  <td style="text-align:center;">-</td>
  <td style="text-align:center;">0</td>
  <td style="text-align:center;">no</td>
  <td style="text-align:center;">no</td>
  <td>published with [1] - never got this to work well</td>
</tr>
</tbody>
</table>

<h2 id="references">References</h2>

<p><code>[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</code></p>

<div class="footnotes">
<hr />
<ol>
<li id="fn-2">
<p>radii can also be added in postprocessing with <code><a href="post.html#radii">skeletor.post.radii()</a></code>&#160;<a href="#fnref-2" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">&#8617;</a></p>
</li>

<li id="fn-3">
<p>a mapping from the meshes vertices to skeleton nodes&#160;<a href="#fnref-3" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">&#8617;</a></p>
</li>

<li id="fn-1">
<p>use <code><a href="pre.html#contract">skeletor.pre.contract()</a></code>&#160;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">&#8617;</a></p>
</li>

<li id="fn-1">
<p>use <code><a href="pre.html#contract">skeletor.pre.contract()</a></code>&#160;<a href="#fnref-1" class="footnoteBackLink" title="Jump back to footnote 4 in the text.">&#8617;</a></p>
</li>
</ol>
</div>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1">#    This script is part of skeletonizer (http://www.github.com/schlegelp/skeletonizer).</span>
<span class="c1">#    Copyright (C) 2018 Philipp Schlegel</span>
<span class="c1">#    Modified from https://github.com/aalavandhaann/Py_BL_MeshSkeletonization</span>
<span class="c1">#    by #0K Srinivasan Ramachandran.</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with this program.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The `skeletor.skeletonize` module contains functions to for skeletonization</span>
<span class="sd">of meshes.</span>

<span class="sd">There are several approaches to skeletonizing a mesh. Which one to pick depends</span>
<span class="sd">(among other things) on the shape of your mesh and the skeleton quality you want</span>
<span class="sd">to get out of it. In general, unless you mesh already looks like a tube I</span>
<span class="sd">recommend looking into mesh contraction [^1].</span>

<span class="sd">Please see the documentation of the individual functions for details but here</span>
<span class="sd">is a quick summary:</span>

<span class="sd">| function                                    | speed | robust | radii [^2] | mesh map [^3] | description                                        |</span>
<span class="sd">| ------------------------------------------- | :---: | :----: | :--------: | :-----------: | ---------------------------------------------------|</span>
<span class="sd">| `skeletor.skeletonize.by_wavefront()`       | +++   | ++     | yes        | yes           | works well for tubular meshes                      |</span>
<span class="sd">| `skeletor.skeletonize.by_vertex_clusters()` | ++    | +      | no         | yes           | best with contracted meshes [^1]                   |</span>
<span class="sd">| `skeletor.skeletonize.by_teasar()`          | +     | ++     | no         | yes           | works on mesh surface                              |</span>
<span class="sd">| `skeletor.skeletonize.by_tangent_ball()`    | ++    | 0      | yes        | yes           | works with mesh normals                            |</span>
<span class="sd">| `skeletor.skeletonize.by_edge_collapse()`   | -     | 0      | no         | no            | published with [1] - never got this to work well   |</span>

<span class="sd">[^1]: use `skeletor.pre.contract()`</span>
<span class="sd">[^2]: radii can also be added in postprocessing with `skeletor.post.radii()`</span>
<span class="sd">[^3]: a mapping from the meshes vertices to skeleton nodes</span>

<span class="sd">## References</span>

<span class="sd">`[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.`</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">.edge_collapse</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.vertex_cluster</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.wave</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.teasar</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.tangent_ball</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;numpy&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;by_teasar&#39;</span><span class="p">,</span> <span class="s1">&#39;by_wavefront&#39;</span><span class="p">,</span> <span class="s1">&#39;by_vertex_clusters&#39;</span><span class="p">,</span>
           <span class="s1">&#39;by_edge_collapse&#39;</span><span class="p">,</span> <span class="s1">&#39;by_tangent_ball&#39;</span><span class="p">]</span>
</pre></div>

        </details>

            </section>
                <section id="by_teasar">
                            <div class="attr function"><a class="headerlink" href="#by_teasar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">by_teasar</span><span class="signature">(mesh, inv_dist, root=None, progress=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">by_teasar</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">inv_dist</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Skeletonize a mesh mesh using the TEASAR algorithm [1].</span>

<span class="sd">    This algorithm finds the longest path from a root vertex, invalidates all</span>
<span class="sd">    vertices that are within `inv_dist`. Then picks the second longest (and</span>
<span class="sd">    still valid) path and does the same. Rinse &amp; repeat until all vertices have</span>
<span class="sd">    been invalidated. It&#39;s fast + works very well with tubular meshes, and with</span>
<span class="sd">    `inv_dist` you have control over the level of detail. Note that by its</span>
<span class="sd">    nature the skeleton will be exactly on the surface of the mesh.</span>

<span class="sd">    Based on the implementation by Sven Dorkenwald, Casey Schneider-Mizell and</span>
<span class="sd">    Forrest Collman in `meshparty` (https://github.com/sdorkenw/MeshParty).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh :          mesh obj</span>
<span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
<span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
<span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
<span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
<span class="sd">    inv_dist :      int | float</span>
<span class="sd">                    Distance along the mesh used for invalidation of vertices.</span>
<span class="sd">                    This controls how detailed (or noisy) the skeleton will be.</span>
<span class="sd">    root :          int, optional</span>
<span class="sd">                    Vertex ID of a root. If not provided will use ``0``.</span>
<span class="sd">    progress :      bool, optional</span>
<span class="sd">                    If True, will show progress bar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    skeletor.Skeleton</span>
<span class="sd">                    Holds results of the skeletonization and enables quick</span>
<span class="sd">                    visualization.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Sato, M., Bitter, I., Bender, M. A., Kaufman, A. E., &amp; Nakajima, M.</span>
<span class="sd">        (n.d.). TEASAR: tree-structure extraction algorithm for accurate and</span>
<span class="sd">        robust skeletons. In Proceedings the Eighth Pacific Conference on</span>
<span class="sd">        Computer Graphics and Applications. IEEE Comput. Soc.</span>
<span class="sd">        https://doi.org/10.1109/pccga.2000.883951</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Generate Graph (must be undirected)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Invalidating&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">),</span>
              <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">clusters</span><span class="p">():</span>
            <span class="c1"># Make a subgraph for this connected component</span>
            <span class="n">SG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

            <span class="c1"># Find a root in this subgraph</span>
            <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">:</span>
                <span class="n">this_root</span> <span class="o">=</span> <span class="n">root</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Get the sparse adjacency matrix of the subgraph</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_adjacency_sparse</span><span class="p">(</span><span class="s1">&#39;weight&#39;</span><span class="p">)</span>

            <span class="c1"># Get lengths of paths to all nodes from root</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">this_root</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ALL&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>

            <span class="c1"># Prep array for invalidation</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">invalidated</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid</span><span class="p">):</span>
                <span class="c1"># Find the farthest point</span>
                <span class="n">farthest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>

                <span class="c1"># Get path from root to farthest point</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_shortest_paths</span><span class="p">(</span><span class="n">this_root</span><span class="p">,</span> <span class="n">farthest</span><span class="p">,</span>
                                             <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ALL&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Add these new edges</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cc</span><span class="p">[</span><span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cc</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]))</span><span class="o">.</span><span class="n">T</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Invalidate points in the path</span>
                <span class="n">valid</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Must set weights along path to 0 so that this path is</span>
                <span class="c1"># taken again in future iterations</span>
                <span class="n">eids</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">get_eids</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">SG</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">eids</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Get all nodes within `inv_dist` to this path</span>
                <span class="c1"># Note: can we somehow only include still valid nodes to speed</span>
                <span class="c1"># things up?</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">sources</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                            <span class="n">limit</span><span class="o">=</span><span class="n">inv_dist</span><span class="p">,</span> <span class="n">min_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Invalidate</span>
                <span class="n">in_dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">inv_dist</span>
                <span class="n">to_invalidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">in_dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">valid</span><span class="p">[</span><span class="n">to_invalidate</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">to_invalidate</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Update mesh vertex to skeleton node map</span>
                <span class="n">mesh_map</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="n">in_dist</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="n">sources</span><span class="p">[</span><span class="n">in_dist</span><span class="p">]]</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="o">~</span><span class="n">valid</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">invalidated</span><span class="p">)</span>
                <span class="n">invalidated</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">valid</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Make unique edges (paths will have overlapped!)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fix_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">weight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Generate the SWC table</span>
    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Update vertex to node ID map</span>
    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mesh_map</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;teasar&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Skeletonize a mesh mesh using the TEASAR algorithm [1].</p>

<p>This algorithm finds the longest path from a root vertex, invalidates all
vertices that are within <code>inv_dist</code>. Then picks the second longest (and
still valid) path and does the same. Rinse &amp; repeat until all vertices have
been invalidated. It's fast + works very well with tubular meshes, and with
<code>inv_dist</code> you have control over the level of detail. Note that by its
nature the skeleton will be exactly on the surface of the mesh.</p>

<p>Based on the implementation by Sven Dorkenwald, Casey Schneider-Mizell and
Forrest Collman in <code>meshparty</code> (https://github.com/sdorkenw/MeshParty).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>inv_dist</strong> (int | float):
Distance along the mesh used for invalidation of vertices.
This controls how detailed (or noisy) the skeleton will be.</li>
<li><strong>root</strong> (int, optional):
Vertex ID of a root. If not provided will use <code>0</code>.</li>
<li><strong>progress</strong> (bool, optional):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="references">References</h6>

<p>[1] Sato, M., Bitter, I., Bender, M. A., Kaufman, A. E., &amp; Nakajima, M.
    (n.d.). TEASAR: tree-structure extraction algorithm for accurate and
    robust skeletons. In Proceedings the Eighth Pacific Conference on
    Computer Graphics and Applications. IEEE Comput. Soc.
    https://doi.org/10.1109/pccga.2000.883951</p>
</div>


                </section>
                <section id="by_wavefront">
                            <div class="attr function"><a class="headerlink" href="#by_wavefront">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">by_wavefront</span><span class="signature">(mesh, waves=1, step_size=1, progress=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">by_wavefront</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">waves</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Skeletonize a mesh using wave fronts.</span>

<span class="sd">    The algorithm tries to find rings of vertices and collapse them to</span>
<span class="sd">    their center. This is done by propagating a wave across the mesh starting at</span>
<span class="sd">    a single seed vertex. As the wave travels across the mesh we keep track of</span>
<span class="sd">    which vertices are are encountered at each step. Groups of connected</span>
<span class="sd">    vertices that are &quot;hit&quot; by the wave at the same time are considered rings</span>
<span class="sd">    and subsequently collapsed. By its nature this works best with tubular meshes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh :          mesh obj</span>
<span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
<span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
<span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
<span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
<span class="sd">    waves :         int</span>
<span class="sd">                    Number of waves to run across the mesh. Each wave is</span>
<span class="sd">                    initialized at a different vertex which produces slightly</span>
<span class="sd">                    different rings. The final skeleton is produced from a mean</span>
<span class="sd">                    across all waves. More waves produce higher resolution</span>
<span class="sd">                    skeletons but also introduce more noise.</span>
<span class="sd">    step_size :     int</span>
<span class="sd">                    Values greater 1 effectively lead to binning of rings. For</span>
<span class="sd">                    example a stepsize of 2 means that two adjacent vertex rings</span>
<span class="sd">                    will be collapsed to the same center. This can help reduce</span>
<span class="sd">                    noise in the skeleton (and as such counteracts a large</span>
<span class="sd">                    number of waves).</span>
<span class="sd">    drop_disconnected : bool</span>
<span class="sd">                    If True, will drop disconnected nodes from the skeleton.</span>
<span class="sd">                    Note that this might result in empty skeletons.</span>
<span class="sd">    progress :      bool</span>
<span class="sd">                    If True, will show progress bar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    skeletor.Skeleton</span>
<span class="sd">                    Holds results of the skeletonization and enables quick</span>
<span class="sd">                    visualization.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Wave must be a positive integer &gt;= 1</span>
    <span class="n">waves</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">waves</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">waves</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`waves` must be integer &gt;= 1&#39;</span><span class="p">)</span>

    <span class="c1"># Same for step size</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">step_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">step_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`step_size` must be integer &gt;= 1&#39;</span><span class="p">)</span>

    <span class="c1"># Generate Graph (must be undirected)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1">#G.es[&#39;weight&#39;] = mesh.edges_unique_length</span>

    <span class="c1"># Prepare empty array to fill with centers</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">waves</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waves</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># Go over each connected component</span>
    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Skeletonizing&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">clusters</span><span class="p">():</span>
            <span class="c1"># Make a subgraph for this connected component</span>
            <span class="n">SG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>

            <span class="c1"># Select seeds according to the number of waves</span>
            <span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                <span class="nb">min</span><span class="p">(</span><span class="n">waves</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Get the distance between the seeds and all other nodes</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SG</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">seeds</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">step_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">mx</span><span class="p">[</span><span class="n">mx</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">step_size</span><span class="p">))</span>

            <span class="c1"># Go over each wave</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">this_wave</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">w</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Collect groups</span>
                <span class="n">mx</span> <span class="o">=</span> <span class="n">this_wave</span><span class="p">[</span><span class="n">this_wave</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">this_dist</span> <span class="o">=</span> <span class="n">this_wave</span> <span class="o">==</span> <span class="n">i</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">this_dist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">SG2</span> <span class="o">=</span> <span class="n">SG</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">SG2</span><span class="o">.</span><span class="n">clusters</span><span class="p">():</span>
                        <span class="n">this_verts</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">cc2</span><span class="p">]]</span>
                        <span class="n">this_center</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">this_verts</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">this_radius</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">this_center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">this_verts</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                        <span class="n">centers</span><span class="p">[</span><span class="n">this_verts</span><span class="p">,</span> <span class="p">:,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_center</span>
                        <span class="n">radii</span><span class="p">[</span><span class="n">this_verts</span><span class="p">,</span> <span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_radius</span>

            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>

    <span class="c1"># Get mean centers and radii over all the waves we casted</span>
    <span class="n">centers_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">radii_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Collapse vertices into nodes</span>
    <span class="p">(</span><span class="n">node_centers</span><span class="p">,</span>
     <span class="n">vertex_to_node_map</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">centers_final</span><span class="p">,</span>
                                     <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Map radii for individual vertices to the collapsed nodes</span>
    <span class="n">node_radii</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii_final</span><span class="p">[</span><span class="n">vertex_to_node_map</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vertex_to_node_map</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">node_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_radii</span><span class="p">)</span>

    <span class="c1"># Contract vertices</span>
    <span class="n">G</span><span class="o">.</span><span class="n">contract_vertices</span><span class="p">(</span><span class="n">vertex_to_node_map</span><span class="p">)</span>

    <span class="c1"># Remove self loops and duplicate edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="c1"># Generate weights</span>
    <span class="n">el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">())</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">node_centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Generate hierarchical tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_tree</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()),</span>
                          <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">)),</span>
                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Generate the SWC table</span>
    <span class="n">swc</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">node_centers</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_radii</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Update vertex to node ID map</span>
    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex_to_node_map</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">vertex_to_node_map</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;wavefront&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Skeletonize a mesh using wave fronts.</p>

<p>The algorithm tries to find rings of vertices and collapse them to
their center. This is done by propagating a wave across the mesh starting at
a single seed vertex. As the wave travels across the mesh we keep track of
which vertices are are encountered at each step. Groups of connected
vertices that are "hit" by the wave at the same time are considered rings
and subsequently collapsed. By its nature this works best with tubular meshes.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>waves</strong> (int):
Number of waves to run across the mesh. Each wave is
initialized at a different vertex which produces slightly
different rings. The final skeleton is produced from a mean
across all waves. More waves produce higher resolution
skeletons but also introduce more noise.</li>
<li><strong>step_size</strong> (int):
Values greater 1 effectively lead to binning of rings. For
example a stepsize of 2 means that two adjacent vertex rings
will be collapsed to the same center. This can help reduce
noise in the skeleton (and as such counteracts a large
number of waves).</li>
<li><strong>drop_disconnected</strong> (bool):
If True, will drop disconnected nodes from the skeleton.
Note that this might result in empty skeletons.</li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>
</div>


                </section>
                <section id="by_vertex_clusters">
                            <div class="attr function"><a class="headerlink" href="#by_vertex_clusters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">by_vertex_clusters</span><span class="signature">(mesh, sampling_dist, cluster_pos=&#39;median&#39;, progress=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">by_vertex_clusters</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">sampling_dist</span><span class="p">,</span> <span class="n">cluster_pos</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Skeletonize a (contracted) mesh by clustering vertices.</span>

<span class="sd">    The algorithm traverses the mesh graph and groups vertices together that</span>
<span class="sd">    are within a given distance to each other. This uses the geodesic</span>
<span class="sd">    (along-the-mesh) distance, not simply the Eucledian distance. Subsequently</span>
<span class="sd">    these groups of vertices are collapsed and re-connected respecting the</span>
<span class="sd">    topology of the input mesh.</span>

<span class="sd">    The graph traversal is fast and scales well, so this method is well suited</span>
<span class="sd">    for meshes with lots of vertices. On the downside: this implementation is</span>
<span class="sd">    not very clever and you might have to play around with the parameters</span>
<span class="sd">    (mostly ``sampling_dist``) to get decent results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh :          mesh obj</span>
<span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
<span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
<span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
<span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
<span class="sd">    sampling_dist : float | int</span>
<span class="sd">                    Maximal distance at which vertices are clustered. This</span>
<span class="sd">                    parameter should be tuned based on the resolution of your</span>
<span class="sd">                    mesh (see Examples).</span>
<span class="sd">    cluster_pos :   &quot;median&quot; | &quot;center&quot;</span>
<span class="sd">                    How to determine the x/y/z coordinates of the collapsed</span>
<span class="sd">                    vertex clusters (i.e. the skeleton&#39;s nodes)::</span>

<span class="sd">                      - &quot;median&quot;: Use the vertex closest to cluster&#39;s center of</span>
<span class="sd">                        mass.</span>
<span class="sd">                      - &quot;center&quot;: Use the center of mass. This makes for smoother</span>
<span class="sd">                        skeletons but can lead to nodes outside the mesh.</span>
<span class="sd">    progress :      bool</span>
<span class="sd">                    If True, will show progress bar.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import skeletor as sk</span>
<span class="sd">    &gt;&gt;&gt; mesh = sk.example_mesh()</span>
<span class="sd">    &gt;&gt;&gt; cont = sk.pre.contract(mesh, epsilon=0.1)</span>
<span class="sd">    &gt;&gt;&gt; skel = sk.skeletonize.vertex_cluster(cont)</span>
<span class="sd">    &gt;&gt;&gt; skel.mesh = mesh</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    skeletor.Skeleton</span>
<span class="sd">                    Holds results of the skeletonization and enables quick</span>
<span class="sd">                    visualization.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cluster_pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">]</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Produce weighted edges</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span>
                            <span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique_length</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                           <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Generate Graph (must be undirected)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

    <span class="c1"># Run the graph traversal that groups vertices into spatial clusters</span>
    <span class="n">not_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Clustering&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">),</span> <span class="n">disable</span><span class="o">=</span><span class="n">progress</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">not_visited</span><span class="p">:</span>
            <span class="c1"># Pick a random node</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">not_visited</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># Get all nodes in the geodesic vicinity</span>
            <span class="n">cl</span><span class="p">,</span> <span class="n">seen</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">dist_traveled</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">max_dist</span><span class="o">=</span><span class="n">sampling_dist</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="n">seen</span><span class="p">)</span>
            <span class="n">cl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>

            <span class="c1"># Append this cluster and track visited/not-visited nodes</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>
            <span class="n">not_visited</span> <span class="o">=</span> <span class="n">not_visited</span> <span class="o">-</span> <span class="n">cl</span>

            <span class="c1"># Update  progress bar</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">to_visit</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">))</span>
            <span class="n">to_visit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_visited</span><span class="p">)</span>

    <span class="c1"># `clusters` is a list of sets -&gt; let&#39;s turn it into list of arrays</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">]</span>

    <span class="c1"># Get positions of clusters</span>
    <span class="k">if</span> <span class="n">cluster_pos</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
        <span class="c1"># Get the center of each cluster</span>
        <span class="n">cl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">cluster_pos</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="c1"># Get the node that&#39;s closest to to the clusters center</span>
        <span class="n">cl_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">cnt_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">median</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cnt_dist</span><span class="p">)]</span>
            <span class="n">cl_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">median</span><span class="p">)</span>
        <span class="n">cl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl_coords</span><span class="p">)</span>

    <span class="c1"># Generate edges</span>
    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">l</span><span class="p">}</span>
        <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
            <span class="n">cl_edges</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Remove directionality from cluster edges</span>
    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Get unique edges</span>
    <span class="n">cl_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cl_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Calculate edge lengths</span>
    <span class="n">co1</span> <span class="o">=</span> <span class="n">cl_coords</span><span class="p">[</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">co2</span> <span class="o">=</span> <span class="n">cl_coords</span><span class="p">[</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">cl_edge_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">co1</span> <span class="o">-</span> <span class="n">co2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Produce adjacency matrix from edges and edge lengths</span>
    <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cl_edge_lengths</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cl_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">))</span>

    <span class="c1"># The cluster graph likely still contain cycles, let&#39;s get rid of them using</span>
    <span class="c1"># a minimum spanning tree</span>
    <span class="n">mst</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csgraph</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span>
                                                     <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Turn into COO matrix</span>
    <span class="n">coo</span> <span class="o">=</span> <span class="n">mst</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

    <span class="c1"># Extract edge list</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Produce final graph - this also takes care of some fixing</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cl_edges</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span>
                       <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Generate a mesh vertex -&gt; skeleton vertex map</span>
    <span class="c1"># Note that nodes are labeled by index of the cluster</span>
    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">]</span>

    <span class="c1"># Generate SWC</span>
    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cl_coords</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Update mesh map</span>
    <span class="n">vertex_to_node_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">vertex_to_node_map</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">vertex_to_node_map</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;vertex_clusters&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Skeletonize a (contracted) mesh by clustering vertices.</p>

<p>The algorithm traverses the mesh graph and groups vertices together that
are within a given distance to each other. This uses the geodesic
(along-the-mesh) distance, not simply the Eucledian distance. Subsequently
these groups of vertices are collapsed and re-connected respecting the
topology of the input mesh.</p>

<p>The graph traversal is fast and scales well, so this method is well suited
for meshes with lots of vertices. On the downside: this implementation is
not very clever and you might have to play around with the parameters
(mostly <code>sampling_dist</code>) to get decent results.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>sampling_dist</strong> (float | int):
Maximal distance at which vertices are clustered. This
parameter should be tuned based on the resolution of your
mesh (see Examples).</li>
<li><p><strong>cluster_pos</strong> ("median" | "center"):
How to determine the x/y/z coordinates of the collapsed
vertex clusters (i.e. the skeleton's nodes)::</p>

<ul>
<li>"median": Use the vertex closest to cluster's center of
mass.</li>
<li>"center": Use the center of mass. This makes for smoother
skeletons but can lead to nodes outside the mesh.</li>
</ul></li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cont</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">contract</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">vertex_cluster</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
</code></pre></div>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>
</div>


                </section>
                <section id="by_edge_collapse">
                            <div class="attr function"><a class="headerlink" href="#by_edge_collapse">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">by_edge_collapse</span><span class="signature">(mesh, shape_weight=1, sample_weight=0.1, progress=True)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">by_edge_collapse</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">shape_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Skeletonize a (contracted) mesh by iteratively collapsing edges.</span>

<span class="sd">    This algorithm (described in [1]) iteratively collapses edges that are part</span>
<span class="sd">    of a face until no more faces are left. Edges are chosen based on a cost</span>
<span class="sd">    function that penalizes collapses that would change the shape of the object</span>
<span class="sd">    or would introduce long edges.</span>

<span class="sd">    This is somewhat sensitive to the dimensions of the input mesh: too large</span>
<span class="sd">    and you might experience slow-downs or numpy OverflowErrors; too low and</span>
<span class="sd">    you might get skeletons that don&#39;t quite match the mesh (e.g. too few nodes).</span>
<span class="sd">    If you experience either, try down- or up-scaling your mesh, respectively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh :          mesh obj</span>
<span class="sd">                    The mesh to be skeletonize. Can an object that has</span>
<span class="sd">                    ``.vertices`` and ``.faces`` properties  (e.g. a</span>
<span class="sd">                    trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
<span class="sd">                    dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>
<span class="sd">    shape_weight :  float, optional</span>
<span class="sd">                    Weight for shape costs which penalize collapsing edges that</span>
<span class="sd">                    would drastically change the shape of the object.</span>
<span class="sd">    sample_weight : float, optional</span>
<span class="sd">                    Weight for sampling costs which penalize collapses that</span>
<span class="sd">                    would generate prohibitively long edges.</span>
<span class="sd">    progress :      bool</span>
<span class="sd">                    If True, will show progress bar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    skeletor.Skeleton</span>
<span class="sd">                    Holds results of the skeletonization and enables quick</span>
<span class="sd">                    visualization.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh</span>
<span class="sd">        contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Shorthand faces and edges</span>
    <span class="c1"># We convert to arrays to (a) make a copy and (b) remove potential overhead</span>
    <span class="c1"># from these originally being trimesh TrackedArrays</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">)</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="c1"># For cost calculations we will normalise coordinates</span>
    <span class="c1"># This prevents getting ridiculuously large cost values ?e300</span>
    <span class="c1"># verts = (verts - verts.min()) / (verts.max() - verts.min())</span>
    <span class="n">edge_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Get a list of faces: [(edge1, edge2, edge3), ...]</span>
    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">faces_unique_edges</span><span class="p">)</span>
    <span class="c1"># Make sure these faces are unique, i.e. no [(e1, e2, e3), (e3, e2, e1)]</span>
    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">face_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Shape cost initialisation:</span>
    <span class="c1"># Each vertex has a matrix Q which is used to determine the shape cost</span>
    <span class="c1"># of collapsing each node. We need to generate a matrix (Q) for each</span>
    <span class="c1"># vertex, then when we collapse two nodes, we can update using</span>
    <span class="c1"># Qj &lt;- Qi + Qj, so the edges previously associated with vertex i</span>
    <span class="c1"># are now associated with vertex j.</span>

    <span class="c1"># For each edge, generate a matrix (K). K is made up of two sets of</span>
    <span class="c1"># coordinates in 3D space, a and b. a is the normalised edge vector</span>
    <span class="c1"># of edge(i,j) and b = a * &lt;x/y/z coordinates of vertex i&gt;</span>
    <span class="c1">#</span>
    <span class="c1"># The matrix K takes the form:</span>
    <span class="c1">#</span>
    <span class="c1">#        Kij = 0, -az, ay, -bx</span>
    <span class="c1">#              az, 0, -ax, -by</span>
    <span class="c1">#             -ay, ax, 0,  -bz</span>

    <span class="n">edge_co0</span><span class="p">,</span> <span class="n">edge_co1</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_co1</span> <span class="o">-</span> <span class="n">edge_co0</span><span class="p">)</span> <span class="o">/</span> <span class="n">edge_lengths</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Note: It&#39;s a bit unclear to me whether the normalised edge vector should</span>
    <span class="c1"># be allowed to have negative values but I seem to be getting better</span>
    <span class="c1"># results if I use absolute values</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">edge_co0</span>

    <span class="c1"># Bunch of zeros</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Generate matrix K</span>
    <span class="n">K</span> <span class="o">=</span> <span class="p">[[</span><span class="n">zero</span><span class="p">,</span>    <span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>    <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]],</span>
         <span class="p">[</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>  <span class="n">zero</span><span class="p">,</span>    <span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>   <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span>
         <span class="p">[</span><span class="o">-</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">zero</span><span class="p">,</span>       <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

    <span class="c1"># Q for vertex i is then the sum of the products of (kT,k) for ALL edges</span>
    <span class="c1"># connected to vertex i:</span>
    <span class="c1"># Initialize matrix of correct shape</span>
    <span class="n">Q_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Generate (kT, K)</span>
    <span class="n">kT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># To get the sum of the products in the correct format we have to</span>
    <span class="c1"># do some annoying transposes to get to (4, 4, len(edges))</span>
    <span class="n">K_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">kT</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Iterate over all vertices</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)):</span>
        <span class="c1"># Find edges that contain this vertex</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span>
        <span class="c1"># Note that this does not take directionality of edges into account</span>
        <span class="c1"># Not sure if that&#39;s intended?</span>

        <span class="c1"># Get indices of these edges</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond1</span> <span class="o">|</span> <span class="n">cond2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the products for all edges adjacent to mesh</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">K_dot</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">indices</span><span class="p">]</span>
        <span class="c1"># Sum over all edges</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Add to Q array</span>
        <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>

    <span class="c1"># Not sure if we are doing something wrong when calculating the Q array but</span>
    <span class="c1"># we end up having negative values which translate into negative scores.</span>
    <span class="c1"># This in turn is bad because we propagate that negative score when</span>
    <span class="c1"># collapsing edges which leads to a &quot;zipper-effect&quot; where nodes collapse</span>
    <span class="c1"># in sequence a-&gt;b-&gt;c-&gt;d until they hit some node with really high cost</span>
    <span class="c1"># Q_array -= Q_array.min()</span>

    <span class="c1"># Edge collapse:</span>
    <span class="c1"># Determining which edge to collapse is a weighted sum of the shape and</span>
    <span class="c1"># sampling cost. The shape cost of vertex i is Fa(p) = pT Qi p where p is</span>
    <span class="c1"># the coordinates of point p (vertex i here) in homogeneous representation.</span>
    <span class="c1"># The variable w from above is the value for the homogeneous 4th dimension.</span>
    <span class="c1"># T denotes transpose of matrix.</span>
    <span class="c1"># The shape cost of collapsing the edge Fa(i,j) = Fi(vj) + Fj(vj).</span>
    <span class="c1"># vi and vj being the coordinates of the vertex in homogeneous representation</span>
    <span class="c1"># (p in equation before)</span>
    <span class="c1"># The sampling cost penalises edge collapses that generate overly long edges,</span>
    <span class="c1"># based on the distance traveled by all edges to vi, when vi is merged with</span>
    <span class="c1"># vj. (Eq. 7 in paper)</span>
    <span class="c1"># You cannot collapse an edge (i -&gt; j) if k is a common adjacent vertex of</span>
    <span class="c1"># both i and j, but (i/j/k) is not a face.</span>
    <span class="c1"># We will set the cost of these edges to infinity.</span>

    <span class="c1"># Now work out the shape cost of collapsing each node (eq. 7)</span>
    <span class="c1"># First get coordinates of the first node of each edge</span>
    <span class="c1"># Note that in Nik&#39;s implementation this was the second node</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>

    <span class="c1"># Append weight factor</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">w</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">this_Q1</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">this_Q2</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>

    <span class="n">F1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">this_Q1</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">this_Q2</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># Calculate and append shape cost</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">shape_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Sum lengths of all edges associated with a given vertex</span>
    <span class="c1"># This is easiest by generating a sparse matrix from the edges</span>
    <span class="c1"># and then summing by row</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">edge_lengths</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                                  <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># This makes sure the matrix is symmetrical, i.e. a-&gt;b == a&lt;-b</span>
    <span class="c1"># Note that I&#39;m not sure whether this is strictly necessary but it really</span>
    <span class="c1"># can&#39;t hurt</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span> <span class="o">+</span> <span class="n">adj</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Get the lengths associated with each vertex</span>
    <span class="n">verts_lengths</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># We need to flatten this (something funny with summing sparse matrices)</span>
    <span class="n">verts_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verts_lengths</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Map the sum of vertex lengths onto edges (as per first vertex in edge)</span>
    <span class="n">ik_edge</span> <span class="o">=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>

    <span class="c1"># Calculate sampling cost</span>
    <span class="n">sample_cost</span> <span class="o">=</span> <span class="n">edge_lengths</span> <span class="o">*</span> <span class="p">(</span><span class="n">ik_edge</span> <span class="o">-</span> <span class="n">edge_lengths</span><span class="p">)</span>

    <span class="c1"># Determine which edge to collapse and collapse it</span>
    <span class="c1"># Total Cost - weighted sum of shape and sample cost, equation 8 in paper</span>
    <span class="n">F_T</span> <span class="o">=</span> <span class="n">shape_cost</span> <span class="o">*</span> <span class="n">shape_weight</span> <span class="o">+</span> <span class="n">sample_cost</span> <span class="o">*</span> <span class="n">sample_weight</span>

    <span class="c1"># Now start collapsing edges one at a time</span>
    <span class="n">face_count</span> <span class="o">=</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># keep track of face counts for progress bar</span>
    <span class="n">is_collapsed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Collapsing edges&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">face_count</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="n">progress</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">pbar</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># Uncomment to get a more-or-less random edge collapse</span>
            <span class="c1"># F_T[:] = 0</span>

            <span class="c1"># Update progress bar</span>
            <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">face_count</span> <span class="o">-</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">face_count</span> <span class="o">=</span> <span class="n">face_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># This has to come at the beginning of the loop</span>
            <span class="c1"># Set cost of collapsing edges without faces to infinite</span>
            <span class="n">F_T</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">F_T</span><span class="p">[</span><span class="n">is_collapsed</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="c1"># Get the edge that we want to collapse</span>
            <span class="n">collapse_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">F_T</span><span class="p">)</span>
            <span class="c1"># Get the vertices this edge connects</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">collapse_ix</span><span class="p">]</span>
            <span class="c1"># Get all edges that contain these vertices:</span>
            <span class="c1"># First, edges that are (uv, x)</span>
            <span class="n">connects_uv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>
            <span class="c1"># Second, check if any (uv, x) edges are (uv, uv)</span>
            <span class="n">connects_uv</span><span class="p">[</span><span class="n">connects_uv</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">connects_uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>

            <span class="c1"># Remove uu and vv edges</span>
            <span class="n">uuvv</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">connects_uv</span> <span class="o">=</span> <span class="n">connects_uv</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">uuvv</span>
            <span class="c1"># Get the edge&#39;s indices</span>
            <span class="n">clps_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">connects_uv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Now find find the faces the collapsed edge is part of</span>
            <span class="c1"># Note: splitting this into three conditions is marginally faster than</span>
            <span class="c1"># np.any(np.isin(face_edges, clps_edges), axis=1)</span>
            <span class="n">uv0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
            <span class="n">uv1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
            <span class="n">uv2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">face_edges</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">clps_edges</span><span class="p">)</span>
            <span class="n">has_uv</span> <span class="o">=</span> <span class="n">uv0</span> <span class="o">|</span> <span class="n">uv1</span> <span class="o">|</span> <span class="n">uv2</span>

            <span class="c1"># If these edges do not have adjacent faces anymore</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">has_uv</span><span class="p">):</span>
                <span class="c1"># Track this edge as a keeper</span>
                <span class="n">keep</span><span class="p">[</span><span class="n">clps_edges</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>

            <span class="c1"># Get the collapsed faces [(e1, e2, e3), ...] for this edge</span>
            <span class="n">clps_faces</span> <span class="o">=</span> <span class="n">face_edges</span><span class="p">[</span><span class="n">has_uv</span><span class="p">]</span>

            <span class="c1"># Remove the collapsed faces</span>
            <span class="n">face_edges</span> <span class="o">=</span> <span class="n">face_edges</span><span class="p">[</span><span class="o">~</span><span class="n">has_uv</span><span class="p">]</span>

            <span class="c1"># Track these edges as collapsed</span>
            <span class="n">is_collapsed</span><span class="p">[</span><span class="n">clps_edges</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Get the adjacent edges (i.e. non-uv edges)</span>
            <span class="n">adj_edges</span> <span class="o">=</span> <span class="n">clps_faces</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">clps_faces</span><span class="p">,</span> <span class="n">clps_edges</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">clps_faces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># We have to do some sorting and finding unique edges to make sure</span>
            <span class="c1"># remapping is done correctly further down</span>
            <span class="c1"># NOTE: Not sure we really need this, so leaving it out for now</span>
            <span class="c1"># adj_edges = np.unique(np.sort(adj_edges, axis=1), axis=0)</span>

            <span class="c1"># We need to keep track of changes to the adjacent faces</span>
            <span class="c1"># Basically each face in (i, j, k) will be reduced to one edge</span>
            <span class="c1"># which points from u -&gt; v</span>
            <span class="c1"># -&gt; replace occurrences of loosing edge with winning edge</span>
            <span class="k">for</span> <span class="n">win</span><span class="p">,</span> <span class="n">loose</span> <span class="ow">in</span> <span class="n">adj_edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
                    <span class="n">face_edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">face_edges</span><span class="p">,</span> <span class="p">{</span><span class="n">loose</span><span class="p">:</span> <span class="n">win</span><span class="p">},</span>
                                                 <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">face_edges</span><span class="p">[</span><span class="n">face_edges</span> <span class="o">==</span> <span class="n">loose</span><span class="p">]</span> <span class="o">=</span> <span class="n">win</span>
                <span class="n">is_collapsed</span><span class="p">[</span><span class="n">loose</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Replace occurrences of first node u with second node v</span>
            <span class="k">if</span> <span class="n">fastremap</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">fastremap</span><span class="o">.</span><span class="n">remap</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="n">v</span><span class="p">},</span>
                                        <span class="n">preserve_missing_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="p">[</span><span class="n">edges</span> <span class="o">==</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="c1"># Add shape cost of u to shape costs of v</span>
            <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span>

            <span class="c1"># Determine which edges require update of costs:</span>
            <span class="c1"># In theory we only need to update costs for edges that are</span>
            <span class="c1"># associated with vertices v and u (which now also v)</span>
            <span class="n">has_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>

            <span class="c1"># Uncomment to temporarily force updating costs for all edges</span>
            <span class="c1"># has_v[:] = True</span>

            <span class="c1"># Update shape costs</span>
            <span class="n">this_Q1</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">this_Q2</span> <span class="o">=</span> <span class="n">Q_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">F1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">this_Q1</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="n">F2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,kji-&gt;ij&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">this_Q2</span><span class="p">)[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">new_shape_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Update sum of incoming edge lengths</span>
            <span class="c1"># Technically we would have to recalculate lengths of adjacent edges</span>
            <span class="c1"># every time but we will take the cheap way out and simply add them up</span>
            <span class="n">verts_lengths</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="c1"># Update sample costs for edges associated with v</span>
            <span class="n">ik_edge</span> <span class="o">=</span> <span class="n">verts_lengths</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">has_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">new_sample_cost</span> <span class="o">=</span> <span class="n">edge_lengths</span><span class="p">[</span><span class="n">has_v</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ik_edge</span> <span class="o">-</span> <span class="n">edge_lengths</span><span class="p">[</span><span class="n">has_v</span><span class="p">])</span>

            <span class="n">F_T</span><span class="p">[</span><span class="n">has_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_shape_cost</span> <span class="o">*</span> <span class="n">shape_weight</span> <span class="o">+</span> <span class="n">new_sample_cost</span> <span class="o">*</span> <span class="n">sample_weight</span>

    <span class="c1"># After the edge collapse, the edges are garbled - I have yet to figure out</span>
    <span class="c1"># why and whether that can be prevented. However the vertices in those</span>
    <span class="c1"># edges are correct and so we just need to reconstruct their connectivity</span>
    <span class="c1"># by extracting a minimum spanning tree over the mesh.</span>
    <span class="n">corrected_edges</span> <span class="o">=</span> <span class="n">mst_over_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="c1"># Generate graph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">corrected_edges</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;edge_collapse&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Skeletonize a (contracted) mesh by iteratively collapsing edges.</p>

<p>This algorithm (described in [1]) iteratively collapses edges that are part
of a face until no more faces are left. Edges are chosen based on a cost
function that penalizes collapses that would change the shape of the object
or would introduce long edges.</p>

<p>This is somewhat sensitive to the dimensions of the input mesh: too large
and you might experience slow-downs or numpy OverflowErrors; too low and
you might get skeletons that don't quite match the mesh (e.g. too few nodes).
If you experience either, try down- or up-scaling your mesh, respectively.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
<li><strong>shape_weight</strong> (float, optional):
Weight for shape costs which penalize collapsing edges that
would drastically change the shape of the object.</li>
<li><strong>sample_weight</strong> (float, optional):
Weight for sampling costs which penalize collapses that
would generate prohibitively long edges.</li>
<li><strong>progress</strong> (bool):
If True, will show progress bar.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="references">References</h6>

<p>[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh
    contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</p>
</div>


                </section>
                <section id="by_tangent_ball">
                            <div class="attr function"><a class="headerlink" href="#by_tangent_ball">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">by_tangent_ball</span><span class="signature">(mesh)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">by_tangent_ball</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Skeletonize a mesh by finding the maximal tangent ball.</span>

<span class="sd">    This algorithm casts a ray from every mesh vertex along its inverse normals</span>
<span class="sd">    (requires `ncollpyde`). It then creates a sphere that is tangent to the</span>
<span class="sd">    vertex and to where the ray hit the inside of a face on the opposite side.</span>
<span class="sd">    Next it drops spheres that overlap with another, larger sphere. Modified</span>
<span class="sd">    from [1].</span>

<span class="sd">    The method works best on smooth meshes and is rather sensitive to errors in</span>
<span class="sd">    the mesh such as incorrect normals (see `skeletor.pre.fix_mesh`), internal</span>
<span class="sd">    faces, noisy surface (try smoothing or downsampling) or holes in the mesh.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesh :              mesh obj</span>
<span class="sd">                        The mesh to be skeletonize. Can an object that has</span>
<span class="sd">                        ``.vertices`` and ``.faces`` properties  (e.g. a</span>
<span class="sd">                        trimesh.Trimesh) or a tuple ``(vertices, faces)`` or a</span>
<span class="sd">                        dictionary ``{&#39;vertices&#39;: vertices, &#39;faces&#39;: faces}``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    skeletor.Skeleton</span>
<span class="sd">                        Holds results of the skeletonization and enables quick</span>
<span class="sd">                        visualization.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import skeletor as sk</span>
<span class="sd">    &gt;&gt;&gt; mesh = sk.example_mesh()</span>
<span class="sd">    &gt;&gt;&gt; fixed = sk.pre.fix_mesh(mesh, fix_normals=True, remove_disconnected=10)</span>
<span class="sd">    &gt;&gt;&gt; skel = sk.skeletonize.by_tangent_ball(fixed)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Ma, J., Bae, S.W. &amp; Choi, S. 3D medial axis point approximation using</span>
<span class="sd">        nearest neighbors and the normal field. Vis Comput 28, 719 (2012).</span>
<span class="sd">        https://doi.org/10.1007/s00371-011-0594-7</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ncollpyde</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;Tangent ball skeletonization requires the &#39;</span>
                          <span class="s1">&#39;`ncollpyde` package for ray-casting: &#39;</span>
                          <span class="s1">&#39;pip install ncollpyde&#39;</span><span class="p">)</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">make_trimesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Generate the KD tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">coll</span> <span class="o">=</span> <span class="n">ncollpyde</span><span class="o">.</span><span class="n">Volume</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sources</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span> <span class="o">*</span> <span class="mf">0.01</span>
    <span class="n">targets</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertex_normals</span> <span class="o">*</span> <span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">ix</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">is_backface</span> <span class="o">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">intersections</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>

    <span class="c1"># Now we need to invalidate centers</span>
    <span class="n">intersects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">intersects</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="n">is_backface</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">centers</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">loc</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">radii</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">loc</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Now we need to post processing</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Invalidate vertices that didn&#39;t intersect</span>
    <span class="n">inv</span><span class="p">[</span><span class="o">~</span><span class="n">intersects</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Now invalidate any ball that is outside the mesh</span>
    <span class="n">inv</span><span class="p">[</span><span class="o">~</span><span class="n">coll</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">centers</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Find tangent balls that are fully contained in another tangent ball</span>
    <span class="c1"># (those are not maximal inscribed)</span>
    <span class="n">original_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">tree2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span>
        <span class="c1"># For any not-yet-invalidated center find the closest other center</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="n">tree2</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Drop self-hits</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dist</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># In radius</span>
        <span class="n">in_radius</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">]</span>

        <span class="c1"># Stop if no more overlapping pairs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_radius</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">break</span>

        <span class="c1"># Collect radii to determine which of the overlapping ball survives</span>
        <span class="n">pair_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">in_radius</span><span class="p">],</span>
                              <span class="n">radii</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">ix</span><span class="p">[</span><span class="n">in_radius</span><span class="p">]]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">pair_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">in_radius</span><span class="p">],</span>
                             <span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">][</span><span class="n">ix</span><span class="p">[</span><span class="n">in_radius</span><span class="p">]]))</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Invalidate the loosers</span>
        <span class="n">looses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pair_rad</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">looser_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pair_ix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pair_ix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">looses</span><span class="p">])</span>
        <span class="n">inv</span><span class="p">[</span><span class="n">looser_ix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Now we need to collapse nodes into the remaining centers</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                 <span class="n">edges</span><span class="o">=</span><span class="n">mesh</span><span class="o">.</span><span class="n">edges_unique</span><span class="p">,</span>
                 <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Make sure that every connected component has at least one valid target</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">clusters</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">inv</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="c1"># For each invalidated vertex, find the closest vertex that is still valid</span>
    <span class="c1"># This works on unweighted edges but should be good enough - way faster</span>
    <span class="c1"># than a proper path search for sure</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">find_closest</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="n">original_ind</span><span class="p">[</span><span class="n">inv</span><span class="p">],</span>
                         <span class="n">targets</span><span class="o">=</span><span class="n">original_ind</span><span class="p">[</span><span class="o">~</span><span class="n">inv</span><span class="p">])</span>

    <span class="c1"># Generate a mesh vertex to skeleton node map</span>
    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">original_ind</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mesh_map</span><span class="p">[</span><span class="n">pairs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Renumber the vertices from 0 -&gt; N_vertices</span>
    <span class="n">uni</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Make sure centers and radii match the new order</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">uni</span><span class="p">]</span>

    <span class="c1"># Contract vertices to nodes according to the mesh</span>
    <span class="n">G</span><span class="o">.</span><span class="n">contract_vertices</span><span class="p">(</span><span class="n">mesh_map</span><span class="p">,</span> <span class="n">combine_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># This only drops duplicate and self-loop edges</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

    <span class="c1"># Generate weights between remaining centers</span>
    <span class="n">el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">())</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">centers</span><span class="p">[</span><span class="n">el</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Generate hierarchical tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">spanning_tree</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Create a directed acyclic and hierarchical graph</span>
    <span class="n">G_nx</span> <span class="o">=</span> <span class="n">edges_to_graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()),</span>
                          <span class="n">nodes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vs</span><span class="p">)),</span>
                          <span class="n">fix_tree</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">drop_disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Generate the SWC table</span>
    <span class="n">swc</span> <span class="o">=</span> <span class="n">make_swc</span><span class="p">(</span><span class="n">G_nx</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">reindex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">swc</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Update vertex to node ID map</span>
    <span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mesh_map</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="n">mesh_map</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;tangent_ball&#39;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Skeletonize a mesh by finding the maximal tangent ball.</p>

<p>This algorithm casts a ray from every mesh vertex along its inverse normals
(requires <code>ncollpyde</code>). It then creates a sphere that is tangent to the
vertex and to where the ray hit the inside of a face on the opposite side.
Next it drops spheres that overlap with another, larger sphere. Modified
from [1].</p>

<p>The method works best on smooth meshes and is rather sensitive to errors in
the mesh such as incorrect normals (see <code><a href="pre.html#fix_mesh">skeletor.pre.fix_mesh</a></code>), internal
faces, noisy surface (try smoothing or downsampling) or holes in the mesh.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (mesh obj):
The mesh to be skeletonize. Can an object that has
<code>.vertices</code> and <code>.faces</code> properties  (e.g. a
trimesh.Trimesh) or a tuple <code>(vertices, faces)</code> or a
dictionary <code>{'vertices': vertices, 'faces': faces}</code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong><a href="../skeletor.html#Skeleton">skeletor.Skeleton</a></strong>: Holds results of the skeletonization and enables quick
visualization.</li>
</ul>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">fix_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">fix_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_disconnected</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">by_tangent_ball</span><span class="p">(</span><span class="n">fixed</span><span class="p">)</span>
</code></pre></div>

<h6 id="references">References</h6>

<p>[1] Ma, J., Bae, S.W. &amp; Choi, S. 3D medial axis point approximation using
    nearest neighbors and the normal field. Vis Comput 28, 719 (2012).
    https://doi.org/10.1007/s00371-011-0594-7</p>
</div>


                </section>
    </main>
</body>
</html>